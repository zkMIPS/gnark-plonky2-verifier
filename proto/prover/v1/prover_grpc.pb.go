// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.26.0--rc3
// source: proto/prover/v1/prover.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	ProverService_GetStatus_FullMethodName     = "/prover.v1.ProverService/GetStatus"
	ProverService_GetTaskResult_FullMethodName = "/prover.v1.ProverService/GetTaskResult"
	ProverService_SplitElf_FullMethodName      = "/prover.v1.ProverService/SplitElf"
	ProverService_Prove_FullMethodName         = "/prover.v1.ProverService/Prove"
	ProverService_Aggregate_FullMethodName     = "/prover.v1.ProverService/Aggregate"
	ProverService_AggregateAll_FullMethodName  = "/prover.v1.ProverService/AggregateAll"
	ProverService_FinalProof_FullMethodName    = "/prover.v1.ProverService/FinalProof"
)

// ProverServiceClient is the client API for ProverService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProverServiceClient interface {
	GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error)
	GetTaskResult(ctx context.Context, in *GetTaskResultRequest, opts ...grpc.CallOption) (*GetTaskResultResponse, error)
	SplitElf(ctx context.Context, in *SplitElfRequest, opts ...grpc.CallOption) (*SplitElfResponse, error)
	Prove(ctx context.Context, in *ProveRequest, opts ...grpc.CallOption) (*ProveResponse, error)
	Aggregate(ctx context.Context, in *AggregateRequest, opts ...grpc.CallOption) (*AggregateResponse, error)
	AggregateAll(ctx context.Context, in *AggregateAllRequest, opts ...grpc.CallOption) (*AggregateAllResponse, error)
	FinalProof(ctx context.Context, in *FinalProofRequest, opts ...grpc.CallOption) (*FinalProofResponse, error)
}

type proverServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProverServiceClient(cc grpc.ClientConnInterface) ProverServiceClient {
	return &proverServiceClient{cc}
}

func (c *proverServiceClient) GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error) {
	out := new(GetStatusResponse)
	err := c.cc.Invoke(ctx, ProverService_GetStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proverServiceClient) GetTaskResult(ctx context.Context, in *GetTaskResultRequest, opts ...grpc.CallOption) (*GetTaskResultResponse, error) {
	out := new(GetTaskResultResponse)
	err := c.cc.Invoke(ctx, ProverService_GetTaskResult_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proverServiceClient) SplitElf(ctx context.Context, in *SplitElfRequest, opts ...grpc.CallOption) (*SplitElfResponse, error) {
	out := new(SplitElfResponse)
	err := c.cc.Invoke(ctx, ProverService_SplitElf_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proverServiceClient) Prove(ctx context.Context, in *ProveRequest, opts ...grpc.CallOption) (*ProveResponse, error) {
	out := new(ProveResponse)
	err := c.cc.Invoke(ctx, ProverService_Prove_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proverServiceClient) Aggregate(ctx context.Context, in *AggregateRequest, opts ...grpc.CallOption) (*AggregateResponse, error) {
	out := new(AggregateResponse)
	err := c.cc.Invoke(ctx, ProverService_Aggregate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proverServiceClient) AggregateAll(ctx context.Context, in *AggregateAllRequest, opts ...grpc.CallOption) (*AggregateAllResponse, error) {
	out := new(AggregateAllResponse)
	err := c.cc.Invoke(ctx, ProverService_AggregateAll_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proverServiceClient) FinalProof(ctx context.Context, in *FinalProofRequest, opts ...grpc.CallOption) (*FinalProofResponse, error) {
	out := new(FinalProofResponse)
	err := c.cc.Invoke(ctx, ProverService_FinalProof_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProverServiceServer is the server API for ProverService service.
// All implementations must embed UnimplementedProverServiceServer
// for forward compatibility
type ProverServiceServer interface {
	GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error)
	GetTaskResult(context.Context, *GetTaskResultRequest) (*GetTaskResultResponse, error)
	SplitElf(context.Context, *SplitElfRequest) (*SplitElfResponse, error)
	Prove(context.Context, *ProveRequest) (*ProveResponse, error)
	Aggregate(context.Context, *AggregateRequest) (*AggregateResponse, error)
	AggregateAll(context.Context, *AggregateAllRequest) (*AggregateAllResponse, error)
	FinalProof(context.Context, *FinalProofRequest) (*FinalProofResponse, error)
	mustEmbedUnimplementedProverServiceServer()
}

// UnimplementedProverServiceServer must be embedded to have forward compatible implementations.
type UnimplementedProverServiceServer struct {
}

func (UnimplementedProverServiceServer) GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedProverServiceServer) GetTaskResult(context.Context, *GetTaskResultRequest) (*GetTaskResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTaskResult not implemented")
}
func (UnimplementedProverServiceServer) SplitElf(context.Context, *SplitElfRequest) (*SplitElfResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SplitElf not implemented")
}
func (UnimplementedProverServiceServer) Prove(context.Context, *ProveRequest) (*ProveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Prove not implemented")
}
func (UnimplementedProverServiceServer) Aggregate(context.Context, *AggregateRequest) (*AggregateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Aggregate not implemented")
}
func (UnimplementedProverServiceServer) AggregateAll(context.Context, *AggregateAllRequest) (*AggregateAllResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregateAll not implemented")
}
func (UnimplementedProverServiceServer) FinalProof(context.Context, *FinalProofRequest) (*FinalProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinalProof not implemented")
}
func (UnimplementedProverServiceServer) mustEmbedUnimplementedProverServiceServer() {}

// UnsafeProverServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProverServiceServer will
// result in compilation errors.
type UnsafeProverServiceServer interface {
	mustEmbedUnimplementedProverServiceServer()
}

func RegisterProverServiceServer(s grpc.ServiceRegistrar, srv ProverServiceServer) {
	s.RegisterService(&ProverService_ServiceDesc, srv)
}

func _ProverService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProverServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProverService_GetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProverServiceServer).GetStatus(ctx, req.(*GetStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProverService_GetTaskResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProverServiceServer).GetTaskResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProverService_GetTaskResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProverServiceServer).GetTaskResult(ctx, req.(*GetTaskResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProverService_SplitElf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SplitElfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProverServiceServer).SplitElf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProverService_SplitElf_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProverServiceServer).SplitElf(ctx, req.(*SplitElfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProverService_Prove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProverServiceServer).Prove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProverService_Prove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProverServiceServer).Prove(ctx, req.(*ProveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProverService_Aggregate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProverServiceServer).Aggregate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProverService_Aggregate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProverServiceServer).Aggregate(ctx, req.(*AggregateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProverService_AggregateAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregateAllRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProverServiceServer).AggregateAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProverService_AggregateAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProverServiceServer).AggregateAll(ctx, req.(*AggregateAllRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProverService_FinalProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinalProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProverServiceServer).FinalProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProverService_FinalProof_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProverServiceServer).FinalProof(ctx, req.(*FinalProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProverService_ServiceDesc is the grpc.ServiceDesc for ProverService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProverService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "prover.v1.ProverService",
	HandlerType: (*ProverServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStatus",
			Handler:    _ProverService_GetStatus_Handler,
		},
		{
			MethodName: "GetTaskResult",
			Handler:    _ProverService_GetTaskResult_Handler,
		},
		{
			MethodName: "SplitElf",
			Handler:    _ProverService_SplitElf_Handler,
		},
		{
			MethodName: "Prove",
			Handler:    _ProverService_Prove_Handler,
		},
		{
			MethodName: "Aggregate",
			Handler:    _ProverService_Aggregate_Handler,
		},
		{
			MethodName: "AggregateAll",
			Handler:    _ProverService_AggregateAll_Handler,
		},
		{
			MethodName: "FinalProof",
			Handler:    _ProverService_FinalProof_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/prover/v1/prover.proto",
}
